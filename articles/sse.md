# SSE идеален для сценариев, где клиент — пассивный слушатель

# Введение

Когда нужно передавать данные от сервера к клиенту в реальном времени, первое, что приходит в голову — WebSocket. Но что если поток данных односторонний? Что если не нужна сложная инфраструктура и достаточно обычного HTTP?

Server-Sent Events (SSE) — это элегантное решение для задач, где клиент только получает данные: live-уведомления, обновления дашбордов, стриминг логов, мониторинг метрик.

Но как убедиться, что SSE-сервис выдержит нагрузку? Как правильно настроить таймауты, буферизацию и тестирование тысяч одновременных подключений?

В этой статье практическое руководство по созданию полноценного стенда для тестирования SSE, от реализации сервера до симуляции нагрузки.

# SSE 

SSE (Server-Sent Events) — это технология, позволяющая серверу автоматически отправлять данные в браузер по установленному HTTP-соединению

1. Данные идут отлько от сервера к клиенту.
2. Работает через втсроенный в браузер JS-интерфейс (EventSource).
3. При обрыве соединения, браузер сам пытается восстановить его.

Когда использовать?

1. Ленты новостей
2. События мониторинга
3. Уведомления о статусе запущенных в фоновом режиме команд
3. Системные уведомления

**Сравнение с WebSockets**

| Характеристика | EventSource (SSE) | WebSockets |
|:---|:---:|:---:|:---:| 
| Направление | Только от сервера к клиенту | Двустороннее (дуплекс) |
| Протокол | Обычный HTTP | Свой протокол (ws://) |
| Формат | Только текст (UTF-8) | Текст и бинарные данные |
| Переподключение | Встроено «из коробки» | Нужно реализовывать вручную |
| Лимиты | Ограничение на 6 соединений (в HTTP/1.1) | Практически не ограничено |

**Ограничение браузеров**

При использовании HTTP/1.1 браузеры ограничивают количество SSE-соединений до 6 на домен. Если открыть 7 вкладок с одним и тем же сайтом, последние не заработают. Решение — переход на HTTP/2.
 
# Пошаговая реализация

## Шаг 1. Конфигурация проксирования и потоковой передачи

Добавьте эти директивы в блок location, который обрабатывает ваш SSE-путь

```
location /api/sse-notifications {
    proxy_pass http://sse-server;

    # 1. Отключаем буферизацию — самое важное для SSE
    proxy_buffering off;
    proxy_cache off;

    # 2. Настраиваем поддержку долгоживущих соединений
    proxy_http_version 1.1;
    proxy_set_header Connection "";

    # 3. Увеличиваем таймауты, чтобы Nginx не закрывал соединение
    # По умолчанию 60с, для SSE лучше поставить больше (например, 24 часа)
    proxy_read_timeout 86400s;
    
    # 4. (Опционально) Отключаем chunked encoding, если клиент его не ждет
    chunked_transfer_encoding off;
}
```

- **proxy_buffering off**. Nginx по умолчанию ждет, пока накопится достаточно данных от сервера, прежде чем отправить их клиенту. Для SSE это ломает логику мгновенных уведомлений.
- **proxy_read_timeout**. Если сервер долго не шлет события, Nginx разорвет связь по таймауту. Большое значение позволяет держать соединение открытым сутками.

## Шаг 2. 


# Тестирование

```
$ curl -N -v http://localhost:8080/sse-notifications
```
